/**
 *
 * @descripion: funciona como um header que contém todas as bibliotecas, é necessário apenas adicionar
 * essa biblioteca para ter acesso a todas a biblioteca.
 */
#ifndef TOKEN_HPP
#define TOKEN_HPP


////////////////////////////////////////////////////////////////////////////////
// Includes - default libraries - C
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Includes - default libraries - C++
////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <ctime>
#include <ctype.h>
#include <map> 
#include <deque>
#include <memory>
#include <unordered_map>
#include <fstream>
#include <streambuf>
#include <exception>
#include <list>

////////////////////////////////////////////////////////////////////////////////
// Includes - system dependent libraries
////////////////////////////////////////////////////////////////////////////////
#if defined(unix) || defined(__unix) || defined(__unix__) || (defined (__APPLE__) && defined (__MACH__)) // Unix (Linux, *BSD, Mac OS X)
#include <unistd.h> // unix standard library
#include <sys/syscall.h>
#include <sys/types.h>
#include <dirent.h>
#endif

////////////////////////////////////////////////////////////////////////////////
// Includes - my libraries
////////////////////////////////////////////////////////////////////////////////
#include <util.hpp>

////////////////////////////////////////////////////////////////////////////////
// Includes - namespace
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// namespace
////////////////////////////////////////////////////////////////////////////////
namespace token
{
	////////////////////////////////////////////////////////////////////////////////
	// Enum - init in token.cpp
	////////////////////////////////////////////////////////////////////////////////
	enum class type_t {
      column_split, column_token, line_break, line_break_end_token_column
    };
	
	////////////////////////////////////////////////////////////////////////////////
	// Class and structs
	////////////////////////////////////////////////////////////////////////////////
	/**
	 * Guarda o token passado pelo usuário e verifica se existe o token na string passada.
	 * Cada token passado pelo usuário é criado uma struct deste tipo.
	 */
	struct token_t {
        std::string str;
        type_t type;
        bool never_match = false; // é utilizado quando se verifica pela primeira vez que a string não contém mais o token
    
        token_t(const std::string& str, const type_t type) {
            this->str = str;
            this->type = type;
        }
        
        /**
		 * @arg strs: string em que se realizará a busca do token.
		 * @arg str_init_search: posição inicial em @strs que começará a busca pelo token.
		 * @return tuple<@1, @2>:
		 * @1: posição dentro da string do início do token.
		 * Caso não seja encontrado o token retorna: std::string::npos
		 * @2: tamanho do token - this->str.size()
		 * Caso não seja encontrado o token retorna: -1
		 */
        std::tuple<size_t, long> search(const std::string& strs);
        std::tuple<size_t, long> search(const std::string& strs, const long str_init_search);
    };
	
	
	////////////////////////////////////////////////////////////////////////////////
	// Global functions - file: token.cpp
	////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////
	// "Private" functions - file: token.cpp
	////////////////////////////////////////////////////////////////////////////////
	/**
	 * Função que realiza a busca realmente de um token
	 * Está função busca apenas um token.
	 * As chamadas são recursivas.
	 * a diferença entre as duas funções é que uma sempre cria uma substring para realizar a busca
	 * enquanto a segunda reusa a string e muda a posição inicial da busca.
	 */
	template<template<typename> typename T>
	T<std::string> search(const std::string& str,
        std::vector<token_t> token, T<std::string> result);
    
	template<template<typename> typename T>
    T<std::string> search(const std::string& str, const size_t str_init_search,
        std::vector<token_t> token, T<std::string> result);
	
	/**
	 * Função que realiza a busca realmente de um token.
	 * Está função busca apenas um token.
	 * Trata o resultado que o token produz.
	 * As chamadas são recursivas.
	 * Busca um token que afeta que produz um resultado em uma matrix.
	 */
	template<template<typename> typename T, template<typename> typename U>
	T<U<std::string>>
	search_matrix(const std::string& str, 
				  const size_t str_init_search,
			      std::vector<token_t>& token,
			      T<U<std::string>>& result);
    
	////////////////////////////////////////////////////////////////////////////////
	// "Public" functions - file: token.cpp
	////////////////////////////////////////////////////////////////////////////////
	/**
	 * Função realmente que deve ser chamada pelo usuário.
	 * @arg str: string em que será realizado a busca pelo token.
	 * @arg column_split: vector que contém os tokens que "quebram", "partem", a string em diversas colunas
	 * os tokens deste vetor não entram no resultado final da string.
	 * @arg column_token: vector que contém os tokens que "quebram", "partem", a string em diversas colunas
	 * os tokens deste vector entram no resultado final da string, cada token deste se torna uma posição
	 * do vetor. A quantidade deste token no vector final será o número de vezes que ele aparecerá na string @str
	 * @return vector que contém a string dividida segundo os tokens passados na função. Cada token produz uma nova
	 * posição no vector final, embora o token possa entrar no vector final (@column_token) ou não (@column_split)
	 */
    template<template<typename> typename T>
    T<std::string> get(const std::string& str, 
        const std::vector<std::string>& column_split, 
        const std::vector<std::string>& column_token = {});
	
	/**
	 * Função realmente que deve ser chamada pelo usuário.
	 * Exemplo de como usar essa função:
	 * auto excel = token::get_matrix<std::deque, std::vector>(excel_untreated, {"\t"}, {}, {"\n", "\r"});
	 * excel será do tipo std::deque<std::vector<std::string>>
	 * @arg str: string em que será realizado a busca pelo token.
	 * @arg column_split: vector que contém os tokens que "quebram", "partem", a string em diversas colunas
	 * os tokens deste vetor não entram no resultado final da string.
	 * @arg column_token: vector que contém os tokens que "quebram", "partem", a string em diversas colunas
	 * os tokens deste vector entram no resultado final da string, cada token deste se torna uma posição
	 * do vetor. A quantidade deste token no vector final será o número de vezes que ele aparecerá na string @str
	 * @arg line_split: funciona identico ao @column_split, com a diferença que os próximos resultados
	 * serão colocados na linha subsequente da matrix, ou seja, se os resultados eram colocados na linha i
	 * os próximos serão colocados na linha i+1
	 * Este token não integra o resultado.
	 * @arg line_token: funciona identico ao @column_token, com a diferença que os próximos resultados
	 * serão colocados na linha subsequente da matrix, ou seja, se os resultados eram colocados na linha i
	 * os próximos serão colocados na linha i+1
	 * Este token integra o resultado, e é sempre o último token da linha, ou seja, da linha i -> linha nova i+1
	 * que este token produz ao final.
	 * @return matrix que contém a string dividida segundo os tokens passados na função. 
	 * Cada token produz uma nova posição no matrix final:
	 * (@line_split e @line_token) produzem uma nova linha na matrix e 
	 * (@column_split e @column_token) não produzem uma nova linha na matrix, apenas afetam a linha atual da matrix
	 * Embora o token possa entrar na matrix (@column_token e @line_token) ou não (@column_split e @line_split)
	 */
	template<template<typename> typename T, template<typename> typename U>
	T<U<std::string>> get_matrix(const std::string& str, 
			   const std::vector<std::string>& column_split, 
			   const std::vector<std::string>& column_token = {}, 
			   const std::vector<std::string>& line_split = {}, 
			   const std::vector<std::string>& line_token = {});
	
	////////////////////////////////////////////////////////////////////////////////
	// Class error
	////////////////////////////////////////////////////////////////////////////////
	
}
////////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Implementation of template functions
////////////////////////////////////////////////////////////////////////////////
template<template<typename> typename T>
T<std::string> token::get(const std::string& str, 
						  const std::vector<std::string>& column_split, 
						  const std::vector<std::string>& column_token) {
 try {
    std::vector<token_t> token;
    for(const auto& s : column_split) { 
		if(!s.empty()) token.push_back({s, type_t::column_split});
	}
    for(const auto& s : column_token) { 
		if(!s.empty()) token.push_back({s, type_t::column_token});
	}
        
    T<std::string> result = {};
	return search(str, 0, token, result);
	//return search(str, token, result);
 } catch (const std::exception &e) { throw err(e.what()); }
}

template<template<typename> typename T, template<typename> typename U>
T<U<std::string>> token::get_matrix(const std::string& str, 
									const std::vector<std::string>& column_split,
									const std::vector<std::string>& column_token, 
									const std::vector<std::string>& line_split,
									const std::vector<std::string>& line_token) {
 try {
    std::vector<token_t> token;
    for(const auto& s : column_split) { if(!s.empty()) token.push_back({s, type_t::column_split}); }
    for(const auto& s : column_token) { if(!s.empty()) token.push_back({s, type_t::column_token}); }
    for(const auto& s : line_split)   { if(!s.empty()) token.push_back({s, type_t::line_break}); }
    for(const auto& s : line_token)   { if(!s.empty()) token.push_back({s, type_t::line_break_end_token_column}); }
        
    T<U<std::string>> result = {};
	result.push_back({}); // inicializa a primeira linha da matrix
	printf("size: %ld\ntoken: %ld\n", str.size(), token.size());
	return search_matrix(str, 0, token, result);
 } catch (const std::exception &e) { throw err(e.what()); }
}

template<template<typename> typename T>
T<std::string> 
token::search(const std::string& str,
			  std::vector<token_t> token, T<std::string> result) {
 try {
	long token_idx = -1, token_size = -1; size_t token_str_begin = str.size();
	for(size_t i=0; i < token.size(); ++i) { // search for substring
		auto [str_begin, size] = token[i].search(str);
		if(str_begin < token_str_begin) {
			token_idx = i;
			token_size = size; // size of the token that is first find in str
			token_str_begin = str_begin; // begin of position of token in str
		} else if(str_begin == token_str_begin) {
			if(size > token_size) {
				token_idx = i;
				token_size = size; // size of the token that is first find in str
				token_str_begin = str_begin; // begin of position of token in str
			}
		}
	}
		
	if(token_idx != -1) {
		if(token_str_begin > 0) {
			std::string prev_str = str.substr(0, token_str_begin);
			result.push_back(prev_str);
		//printf("prev_str: \"%s\" | token_str_begin: %ld | \n", prev_str.c_str(), token_str_begin);
		}
		
		if(token[token_idx].type == type_t::column_token) {
			result.push_back(token[token_idx].str);
		}
		
		if(token_str_begin+token_size >= str.size()) { // no more string to search
			return result;
		} else {
			std::string new_str = str.substr(token_str_begin+token_size, std::string::npos);
			return search(new_str, token, result); // continue the search
		}
	} else {
		result.push_back(str);
		return result;
	}
 } catch (const std::exception &e) { throw err(e.what()); }
}
template<template<typename> typename T>
T<std::string> 
token::search(const std::string& str, const size_t str_init_search,
			  std::vector<token_t> token, T<std::string> result) {
 try {
	long token_idx = -1, token_size = -1; size_t token_str_begin = str.size();
	for(size_t i=0; i < token.size(); ++i) { // search for substring
		auto [str_begin, size] = token[i].search(str, str_init_search);
		if(str_begin < token_str_begin ||
		  (str_begin == token_str_begin && size > token_size)) {
			token_idx = i;
			token_size = size; // size of the token that is first find in str
			token_str_begin = str_begin; // begin of position of token in str		
		}
	}
		
	if(token_idx != -1) {
		if(token_str_begin > str_init_search) {
			std::string prev_str = str.substr(str_init_search, token_str_begin - str_init_search);
			result.push_back(prev_str);
			//printf("prev_str: \"%s\" | str_init_search: %d | token_str_begin: %ld | \n", prev_str.c_str(), str_init_search, token_str_begin);
		}
			
		if(token[token_idx].type == type_t::column_token) {
			result.push_back(token[token_idx].str);
		}
			
		size_t new_str_init_search = token_str_begin+token_size;
		if(new_str_init_search >= str.size()) { // no more string to search
			return result;
		} else {
			return search(str, new_str_init_search, token, result); // continue the search
		}
		
	} else {
		result.push_back(str.substr(str_init_search));
		return result;
	}
 } catch (const std::exception &e) { throw err(e.what()); }
}

template<template<typename> typename T, template<typename> typename U>
T<U<std::string>>
token::search_matrix(const std::string& str, 
					 const size_t str_init_search,
					 std::vector<token_t>& token, 
					 T<U<std::string>>& result) {
 try {
	////////////////////////////////////////////////////////////////////////////////
	// busca o primeiro token dentro da substring de busca
	////////////////////////////////////////////////////////////////////////////////
	 printf("%d of %d\n", str_init_search, str.size());
	long token_idx = -1, token_size = -1; size_t token_str_begin = str.size();
	for(size_t i=0; i < token.size(); ++i) { // search for substring
		auto [str_begin, size] = token[i].search(str, str_init_search);
		if(str_begin < token_str_begin ||
		  (str_begin == token_str_begin && size > token_size)) {
			token_idx = i;
			token_size = size; // size of the token that is first find in str
			token_str_begin = str_begin; // begin of position of token in str		
		}
	}
		
	if(token_idx != -1) { // encontrou algum token
		if(token_str_begin > str_init_search) { // insere a substring antes do token encontrado
			std::string prev_str = str.substr(str_init_search, token_str_begin - str_init_search);
			result.back().push_back(prev_str);
			//printf("prev_str: \"%s\" | str_init_search: %d | token_str_begin: %ld | \n", prev_str.c_str(), str_init_search, token_str_begin);
		}
		
		////////////////////////////////////////////////////////////////////////////////
		// trata o resultado pelo tipo de token
		////////////////////////////////////////////////////////////////////////////////
		if(token[token_idx].type == type_t::column_token) {
			result.back().push_back(token[token_idx].str);
		} else if(token[token_idx].type == type_t::line_break) {
			result.push_back({}); // insere uma nova linha
		} else if(token[token_idx].type == type_t::line_break_end_token_column) {
			result.back().push_back(token[token_idx].str);
			result.push_back({}); // insere uma nova linha
		} // else => token[token_idx].type == type_t::column_split
		
		////////////////////////////////////////////////////////////////////////////////
		// acerta a nova string que será buscada & recomeça a busca
		////////////////////////////////////////////////////////////////////////////////
		size_t new_str_init_search = token_str_begin+token_size;
		if(new_str_init_search >= str.size()) { // no more string to search
			return result;
		} else {
			return search_matrix(str, new_str_init_search, token, result); // continue the search
		}
		
	} else { // não encontrou token na busca
		result.back().push_back(str.substr(str_init_search));
		return result;
	}
 } catch (const std::exception &e) { throw err(e.what()); }
}
#endif // TOKEN_HPP

////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// SQL create database security
////////////////////////////////////////////////////////////////////////////////





























